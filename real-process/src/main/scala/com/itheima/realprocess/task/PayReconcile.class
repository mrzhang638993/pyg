/**
 * 支付对账
 */
public class PayReconcile {

    //定义侧输出流标签保存对账不匹配的数据
    //订单支付事件
    private final static OutputTag<OrderEvent> unmatchedOrderPay = new OutputTag<OrderEvent>("unmatched_order_pay") {
    };

    //到账事件
    private final static OutputTag<OrderPayCallBackEvent> unmatchedOrderPayCallBack = new OutputTag<OrderPayCallBackEvent>("unmatched_order_pay_callback") {
    };

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        env.setParallelism(1);

        //读取数据源，转换为实体类
        URL orderEventResource = PayReconcile.class.getResource("/orderLog.txt");
        DataStreamSource<String> dataStreamSource1 = env.readTextFile(orderEventResource.getPath());
        DataStream<OrderEvent> orderEventStream = dataStreamSource1.map(line -> {
            String[] split = line.split(",");
            return new OrderEvent(split[0], split[1], split[2], new Long(split[3]));
        }).assignTimestampsAndWatermarks(new AscendingTimestampExtractor<OrderEvent>() {
            @Override
            public long extractAscendingTimestamp(OrderEvent orderEvent) {
                return orderEvent.getTimeStamp() * 1000L;
            }
        }).filter(data -> !"".equals(data.getTransactId()));//过滤得到pay事件

        URL orderPayResource = PayReconcile.class.getResource("/payCallBackLog.txt");
        DataStreamSource<String> dataStreamSource2 = env.readTextFile(orderPayResource.getPath());
        DataStream<OrderPayCallBackEvent> orderPayEventStream = dataStreamSource2.map(line -> {
            String[] split = line.split(",");
            return new OrderPayCallBackEvent(split[0], split[1], new Long(split[2]));
        }).assignTimestampsAndWatermarks(new AscendingTimestampExtractor<OrderPayCallBackEvent>() {
            @Override
            public long extractAscendingTimestamp(OrderPayCallBackEvent orderPayEvent) {
                return orderPayEvent.getTimeStamp() * 1000L;
            }
        });

        //将2条流进行合流操作，检查匹配项
        SingleOutputStreamOperator<Tuple2<OrderEvent, OrderPayCallBackEvent>> resStream = orderEventStream.keyBy(OrderEvent::getTransactId)
                .connect(orderPayEventStream.keyBy(OrderPayCallBackEvent::getTransactId))
                .process(new PayMatchDetection());

        resStream.print("matched_pays");
        resStream.getSideOutput(unmatchedOrderPay).print("unmatched-orders-pay");
        resStream.getSideOutput(unmatchedOrderPayCallBack).print("unmatched-order-pays-callback");

        env.execute("pay reconcile job");
    }

    private static class PayMatchDetection extends CoProcessFunction<OrderEvent, OrderPayCallBackEvent, Tuple2<OrderEvent, OrderPayCallBackEvent>> {
        //定义状态，保存当前已经到来的订单支付事件和支付到账事件
        ValueState<OrderEvent> orderPayState;
        ValueState<OrderPayCallBackEvent> orderPayCallBackState;

        @Override
        public void open(Configuration parameters) throws Exception {
            orderPayState = getRuntimeContext().getState(new ValueStateDescriptor<OrderEvent>("order_pay", OrderEvent.class));
            orderPayCallBackState = getRuntimeContext().getState(new ValueStateDescriptor<OrderPayCallBackEvent>("order_pay_callBack", OrderPayCallBackEvent.class));
        }

        @Override
        public void processElement1(OrderEvent orderEvent, Context context, Collector<Tuple2<OrderEvent, OrderPayCallBackEvent>> collector) throws Exception {
            //订单支付事件到来时判断有没有对应的支付回调事件
            OrderPayCallBackEvent orderPayCallBackEvent = orderPayCallBackState.value();
            if (orderPayCallBackEvent != null) {
                //如果支付回调不为空，说明支付成功回调事件已经到达，输出匹配结果，清空状态
                collector.collect(new Tuple2<>(orderEvent, orderPayCallBackEvent));
                orderPayCallBackState.clear();
                orderPayState.clear();
            } else {
                //如果支付回调事件没来，注册一个5秒钟的定时器
                context.timerService().registerEventTimeTimer((orderEvent.getTimeStamp() + 5) * 1000L);
                //更新订单支付事件状态
                orderPayState.update(orderEvent);
            }
        }

        @Override
        public void processElement2(OrderPayCallBackEvent orderPayCallBackEvent, Context context, Collector<Tuple2<OrderEvent, OrderPayCallBackEvent>> collector) throws Exception {
            //订单支付回调事件到来时判断有没有对应的订单支付事件
            OrderEvent orderEvent = orderPayState.value();
            if (orderEvent != null) {
                //如果订单支付事件不为空，说明订单支付事件已经到达，输出匹配结果，清空状态
                collector.collect(new Tuple2<>(orderEvent, orderPayCallBackEvent));
                orderPayCallBackState.clear();
                orderPayState.clear();
            } else {
                //如果订单支付事件没来，注册一个2秒钟的定时器
                context.timerService().registerEventTimeTimer((orderPayCallBackEvent.getTimeStamp() + 2) * 1000L);
                //更新订单支付事件状态
                orderPayCallBackState.update(orderPayCallBackEvent);
            }
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<Tuple2<OrderEvent, OrderPayCallBackEvent>> out) throws Exception {
            //触发定时器，为了省略删除定时器的操作，可以这样做：
            //如果有一个事件不为空，则另一个对应的事件就还没到达，因为如果两个事件都到达会清空状态，导致两者同时为空
            if (orderPayState.value() != null) {
                ctx.output(unmatchedOrderPay, orderPayState.value());
            }

            if (orderPayCallBackState.value() != null) {
                ctx.output(unmatchedOrderPayCallBack, orderPayCallBackState.value());
            }

            //清空状态
            orderPayState.clear();
            orderPayCallBackState.clear();
        }
    }
}
