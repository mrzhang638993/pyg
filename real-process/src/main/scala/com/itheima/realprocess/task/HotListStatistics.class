/**
 * 热榜统计：每5分钟统计1次1小时内南京地区的热点新闻，输出头条新闻
 */
public class HotListStatistics {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        env.setParallelism(1);

        //简单起见，数据也可从文本文件中读取;并从数据中提取时间戳生成水位线
        //DataStreamSource<String> inputStreamSource = env.readTextFile("D:\\news.txt");
        //从kafka接收输入数据
        Properties props = new Properties();
        props.put("bootstrap.servers", "192.168.244.128:9092");
        props.put("group.id", "news-group");//指定消费者组
        props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");  //key 反序列化
        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.put("auto.offset.reset", "latest"); //value 反序列化

        DataStreamSource<String> inputStreamSource = env.addSource(new FlinkKafkaConsumer<>("topic_hotlist", new SimpleStringSchema(), props));

        DataStream<NewsInfo> dataStream = inputStreamSource.map(line -> {
            String[] split = line.split(",");
            NewsInfo newsInfo = new NewsInfo();
            newsInfo.newsId = split[0];
            newsInfo.categoryId = Integer.parseInt(split[1]);
            newsInfo.city = split[2];
            newsInfo.content = split[3];
            newsInfo.timestamp = Long.parseLong(split[4]);
            return newsInfo;
        })
                //由于输入数据是单调递增的时间戳,可以直接使用Flink提供的水位线生成器MonotonousTimestamps,也可以使用固定延迟的水位线
                .assignTimestampsAndWatermarks(WatermarkStrategy.<NewsInfo>forMonotonousTimestamps()
                        .withTimestampAssigner((element, recordTimestamp) -> element.timestamp));

        //过滤南京地区的热榜;分组开窗聚合,得到每个窗口内各个新闻的count值
        DataStream<NewsWindowCount> aggregateStream = dataStream.filter(e -> e.city.equals("南京"))
                .keyBy(e -> e.newsId)//按照新闻id分组
                .timeWindow(Time.hours(1), Time.minutes(5))//一小时的窗口，每隔5分滑动一次
                .aggregate(new CountAggregation(), new ItemWindowCountFunction());

        //将同一窗口内的新闻按计数值排序，统计topN热点新闻(使用状态编程、定时器)
        DataStream<String> processRes = aggregateStream
                .keyBy("windowEnd")
                .process(new TopNHotListFunction(3));

        processRes.print();

        env.execute("hot list");
    }

    /**
     * 自定义增量聚合函数，完成每个新闻热点的计数累加功能
     */
    static class CountAggregation implements AggregateFunction<NewsInfo, Long, Long> {

        @Override
        public Long createAccumulator() {
            //初始值为0
            return 0L;
        }

        @Override
        public Long add(NewsInfo value, Long accumulator) {
            //每来一次相同的新闻点击数据，计数加一
            return accumulator + 1;
        }

        @Override
        public Long getResult(Long accumulator) {
            return accumulator;
        }

        @Override
        public Long merge(Long a, Long b) {
            return a + b;
        }
    }

    /**
     * 自定义全量窗口聚合函数，输出封装好的ItemWindowCount
     */
    static class ItemWindowCountFunction implements WindowFunction<Long, NewsWindowCount, String, TimeWindow> {
        @Override
        public void apply(String key, TimeWindow window, Iterable<Long> input, Collector<NewsWindowCount> out) throws Exception {
            int size = 0;
            Iterator<Long> iterator = input.iterator();
            while (iterator.hasNext()) {
                iterator.next();
                size++;
            }
            System.out.println("size is:" + size);

            NewsWindowCount newsWindowCount = new NewsWindowCount();
            //这里input迭代器里只有一个元素
            newsWindowCount.count = input.iterator().next();
            newsWindowCount.newsId = key;
            newsWindowCount.windowEnd = window.getEnd();
            out.collect(newsWindowCount);
        }
    }

    static class TopNHotListFunction extends KeyedProcessFunction<Tuple, NewsWindowCount, String> {
        //输出topN的结果数据
        private int topN;

        //先定义状态变量，在生命周期方法里获取
        private ListState<NewsWindowCount> newsWindowCountListState = null;

        public TopNHotListFunction(int topN) {
            this.topN = topN;
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            newsWindowCountListState = getRuntimeContext().getListState(
                    new ListStateDescriptor<>("newsCountListState", NewsWindowCount.class));
        }

        @Override
        public void processElement(NewsWindowCount value, Context ctx, Collector<String> out) throws Exception {
            //每来一个数据直接加入状态ListState中
            newsWindowCountListState.add(value);
            //注册一个windowEnd+1毫秒触发的定时器
            ctx.timerService().registerEventTimeTimer(value.windowEnd + 1);
        }

        /**
         * 当所有所有的窗口统计结果都到达，触发定时器，输出排序
         *
         * @param timestamp
         * @param ctx
         * @param out
         * @throws Exception
         */
        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {
            //将ListState中的数据放到可排序的数据结构里面
            List<NewsWindowCount> newsWindowCounts = new ArrayList<>();
            Iterator<NewsWindowCount> iterator = newsWindowCountListState.get().iterator();
            while (iterator.hasNext()) {
                newsWindowCounts.add(iterator.next());
            }
            //清除状态，节省内存
            newsWindowCountListState.clear();
            newsWindowCounts.sort(new Comparator<NewsWindowCount>() {
                @Override
                public int compare(NewsWindowCount o1, NewsWindowCount o2) {
                    if (o1.count == o2.count) {
                        return 0;
                    } else if (o1.count > o2.count) {
                        return -1;
                    } else {
                        return 1;
                    }
                }
            });

            //将新闻排名格式化输出
            StringBuffer outputStr = new StringBuffer();
            outputStr.append("windowEndTime:").append(new Timestamp(timestamp - 1)).append("\r\n");
            for (int i = 0; i < Math.min(newsWindowCounts.size(), topN); i++) {
                NewsWindowCount newsWindowCount = newsWindowCounts.get(i);
                outputStr.append("No.").append(i + 1)
                        .append(" 新闻ID:").append(newsWindowCount.newsId).append("\t")
                        .append(" 点击量:").append(newsWindowCount.count)
                        .append("\r\n");
            }
            out.collect(outputStr.toString());
        }
    }
}
